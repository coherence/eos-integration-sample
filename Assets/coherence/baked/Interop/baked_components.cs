// Copyright (c) coherence ApS.
// For all coherence generated code, the coherence SDK license terms apply. See the license file in the coherence Package root folder for more information.

// <auto-generated>
// Generated file. DO NOT EDIT!
// </auto-generated>
namespace Coherence.Generated
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections.Generic;
    using Coherence.ProtocolDef;
    using Coherence.Serializer;
    using Coherence.SimulationFrame;
    using Coherence.Entities;
    using Coherence.Utils;
    using Coherence.Brook;
    using Coherence.Core;
    using Logger = Coherence.Log.Logger;
    using UnityEngine;
    using Coherence.Toolkit;
        public struct WorldPosition : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= WorldPosition.valueMask;
                valueSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public Vector3 value;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 0;
            public int PriorityLevel() => 1000;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
            private long[] simulationFrames;
    
            public long[] GetSimulationFrames() {
                if (simulationFrames == null)
                {
                    simulationFrames = new long[1];
                }
    
                simulationFrames[0] = valueSimulationFrame;
    
                return simulationFrames;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => true;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
                if ((FieldsMask & WorldPosition.valueMask) != 0 && (min == null || this.valueSimulationFrame < min))
                {
                    min = this.valueSimulationFrame;
                }
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (WorldPosition)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(WorldPosition data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
                    if (isRefSimFrameValid) {
                        var simFrameDelta = data.valueSimulationFrame - referenceSimulationFrame;
                        if (simFrameDelta > byte.MaxValue) {
                            simFrameDelta = byte.MaxValue;
                        }
    
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, (byte)simFrameDelta);
                    } else {
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, 0);
                    }
    
    
                    var fieldValue = (data.value.ToCoreVector3());
    
                    Coherence.Utils.Bounds.CheckPositionForNanAndInfinity(ref fieldValue, logger);
    
                    bitStream.WriteVector3(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static WorldPosition Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new WorldPosition();
                if (bitStream.ReadMask())
                {
                    val.valueSimulationFrame = referenceSimulationFrame + DeserializerTools.ReadFieldSimFrameDelta(bitStream);
    
                    val.value = bitStream.ReadVector3(FloatMeta.NoCompression()).ToUnityVector3();
                    val.FieldsMask |= WorldPosition.valueMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"WorldPosition(" +
                    $" value: { this.value }" +
                    $", valueSimFrame: { this.valueSimulationFrame }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct WorldOrientation : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= WorldOrientation.valueMask;
                valueSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public Quaternion value;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 1;
            public int PriorityLevel() => 1000;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
            private long[] simulationFrames;
    
            public long[] GetSimulationFrames() {
                if (simulationFrames == null)
                {
                    simulationFrames = new long[1];
                }
    
                simulationFrames[0] = valueSimulationFrame;
    
                return simulationFrames;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
                if ((FieldsMask & WorldOrientation.valueMask) != 0 && (min == null || this.valueSimulationFrame < min))
                {
                    min = this.valueSimulationFrame;
                }
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (WorldOrientation)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(WorldOrientation data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
                    if (isRefSimFrameValid) {
                        var simFrameDelta = data.valueSimulationFrame - referenceSimulationFrame;
                        if (simFrameDelta > byte.MaxValue) {
                            simFrameDelta = byte.MaxValue;
                        }
    
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, (byte)simFrameDelta);
                    } else {
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, 0);
                    }
    
    
                    var fieldValue = (data.value.ToCoreQuaternion());
    

    
                    bitStream.WriteQuaternion(fieldValue, 32);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static WorldOrientation Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new WorldOrientation();
                if (bitStream.ReadMask())
                {
                    val.valueSimulationFrame = referenceSimulationFrame + DeserializerTools.ReadFieldSimFrameDelta(bitStream);
    
                    val.value = bitStream.ReadQuaternion(32).ToUnityQuaternion();
                    val.FieldsMask |= WorldOrientation.valueMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"WorldOrientation(" +
                    $" value: { this.value }" +
                    $", valueSimFrame: { this.valueSimulationFrame }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct LocalUserComponent : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= LocalUserComponent.localIndexMask;
                localIndexSimulationFrame = frame;
            }
    
            public static uint localIndexMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame localIndexSimulationFrame;
            public System.Int32 localIndex;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 2;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
            private static readonly System.Int32 _localIndex_Min = -2147483648;
            private static readonly System.Int32 _localIndex_Max = 2147483647;
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (LocalUserComponent)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.localIndexSimulationFrame = other.localIndexSimulationFrame;
                    this.localIndex = other.localIndex;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(LocalUserComponent data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.localIndex, _localIndex_Min, _localIndex_Max, "LocalUserComponent.localIndex", logger);
    
                    data.localIndex = Coherence.Utils.Bounds.Clamp(data.localIndex, _localIndex_Min, _localIndex_Max);
    
                    var fieldValue = data.localIndex;
    

    
                    bitStream.WriteIntegerRange(fieldValue, 32, -2147483648);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static LocalUserComponent Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new LocalUserComponent();
                if (bitStream.ReadMask())
                {
    
                    val.localIndex = bitStream.ReadIntegerRange(32, -2147483648);
                    val.FieldsMask |= LocalUserComponent.localIndexMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"LocalUserComponent(" +
                    $" localIndex: { this.localIndex }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct WorldPositionQuery : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= WorldPositionQuery.positionMask;
                positionSimulationFrame = frame;
                FieldsMask |= WorldPositionQuery.radiusMask;
                radiusSimulationFrame = frame;
                FieldsMask |= WorldPositionQuery.bufferMask;
                bufferSimulationFrame = frame;
            }
    
            public static uint positionMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame positionSimulationFrame;
            public Vector3 position;
            public static uint radiusMask => 0b00000000000000000000000000000010;
            public AbsoluteSimulationFrame radiusSimulationFrame;
            public System.Single radius;
            public static uint bufferMask => 0b00000000000000000000000000000100;
            public AbsoluteSimulationFrame bufferSimulationFrame;
            public System.Single buffer;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 3;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000111;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 3;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (WorldPositionQuery)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.positionSimulationFrame = other.positionSimulationFrame;
                    this.position = other.position;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.radiusSimulationFrame = other.radiusSimulationFrame;
                    this.radius = other.radius;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.bufferSimulationFrame = other.bufferSimulationFrame;
                    this.buffer = other.buffer;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(WorldPositionQuery data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 3);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = (data.position.ToCoreVector3());
    

    
                    bitStream.WriteVector3(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.radius;
    

    
                    bitStream.WriteFloat(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.buffer;
    

    
                    bitStream.WriteFloat(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static WorldPositionQuery Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(3);
                }
    
                var val = new WorldPositionQuery();
                if (bitStream.ReadMask())
                {
    
                    val.position = bitStream.ReadVector3(FloatMeta.NoCompression()).ToUnityVector3();
                    val.FieldsMask |= WorldPositionQuery.positionMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.radius = bitStream.ReadFloat(FloatMeta.NoCompression());
                    val.FieldsMask |= WorldPositionQuery.radiusMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.buffer = bitStream.ReadFloat(FloatMeta.NoCompression());
                    val.FieldsMask |= WorldPositionQuery.bufferMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"WorldPositionQuery(" +
                    $" position: { this.position }" +
                    $" radius: { this.radius }" +
                    $" buffer: { this.buffer }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(3, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(3, '0') })";
            }
        }
        public struct ArchetypeComponent : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= ArchetypeComponent.indexMask;
                indexSimulationFrame = frame;
            }
    
            public static uint indexMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame indexSimulationFrame;
            public System.Int32 index;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 4;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
            private static readonly System.Int32 _index_Min = -2147483648;
            private static readonly System.Int32 _index_Max = 2147483647;
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (ArchetypeComponent)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.indexSimulationFrame = other.indexSimulationFrame;
                    this.index = other.index;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(ArchetypeComponent data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.index, _index_Min, _index_Max, "ArchetypeComponent.index", logger);
    
                    data.index = Coherence.Utils.Bounds.Clamp(data.index, _index_Min, _index_Max);
    
                    var fieldValue = data.index;
    

    
                    bitStream.WriteIntegerRange(fieldValue, 32, -2147483648);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static ArchetypeComponent Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new ArchetypeComponent();
                if (bitStream.ReadMask())
                {
    
                    val.index = bitStream.ReadIntegerRange(32, -2147483648);
                    val.FieldsMask |= ArchetypeComponent.indexMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"ArchetypeComponent(" +
                    $" index: { this.index }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct Persistence : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
            }
    
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 5;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000000;
            public bool HasFields() => false;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 0;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (Persistence)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(Persistence data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 0);
                }
    
                var mask = data.FieldsMask;
    
    
                return mask;
            }
    
            public static Persistence Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(0);
                }
    
                var val = new Persistence();
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"Persistence(" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(0, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(0, '0') })";
            }
        }
        public struct ConnectedEntity : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= ConnectedEntity.valueMask;
                valueSimulationFrame = frame;
                FieldsMask |= ConnectedEntity.posMask;
                posSimulationFrame = frame;
                FieldsMask |= ConnectedEntity.rotMask;
                rotSimulationFrame = frame;
                FieldsMask |= ConnectedEntity.scaleMask;
                scaleSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public Entity value;
            public static uint posMask => 0b00000000000000000000000000000010;
            public AbsoluteSimulationFrame posSimulationFrame;
            public Vector3 pos;
            public static uint rotMask => 0b00000000000000000000000000000100;
            public AbsoluteSimulationFrame rotSimulationFrame;
            public Quaternion rot;
            public static uint scaleMask => 0b00000000000000000000000000001000;
            public AbsoluteSimulationFrame scaleSimulationFrame;
            public Vector3 scale;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 6;
            public int PriorityLevel() => 100;
            public const int order = -1;
            public uint InitialFieldsMask() => 0b00000000000000000000000000001111;
            public bool HasFields() => true;
            public bool HasRefFields() => true;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 4;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return new HashSet<Entity>()
                {
                    this.value,
                };
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                uint refsMask = 0;
    
                if (this.value == fromEntity)
                {
                    this.value = toEntity;
                    refsMask |= 1u << 0;
                }
    
                FieldsMask |= refsMask;
    
                return refsMask;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                Entity absoluteEntity;
                IEntityMapper.Error err;
                err = mapper.MapToAbsoluteEntity(this.value, false, out absoluteEntity);
    
                if (err != IEntityMapper.Error.None)
                {
                    return err;
                }
    
                this.value = absoluteEntity;
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                Entity relativeEntity;
                IEntityMapper.Error err;
                // We assume that the inConnection held changes with unresolved references, so the 'createMapping=true' is
                // there only because there's a chance that the parent creation change will be processed after this one
                // meaning there's no mapping for the parent yet. This wouldn't be necessary if mapping creation would happen
                // in the clientWorld via create/destroy requests while here we would only check whether mapping exists or not.
                var createParentMapping_value = true;
                err = mapper.MapToRelativeEntity(this.value, createParentMapping_value,
                 out relativeEntity);
    
                if (err != IEntityMapper.Error.None)
                {
                    return err;
                }
    
                this.value = relativeEntity;
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => true;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (ConnectedEntity)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.posSimulationFrame = other.posSimulationFrame;
                    this.pos = other.pos;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.rotSimulationFrame = other.rotSimulationFrame;
                    this.rot = other.rot;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.scaleSimulationFrame = other.scaleSimulationFrame;
                    this.scale = other.scale;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(ConnectedEntity data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 4);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.value;
    

    
                    bitStream.WriteEntity(fieldValue);
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = (data.pos.ToCoreVector3());
    

    
                    bitStream.WriteVector3(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = (data.rot.ToCoreQuaternion());
    

    
                    bitStream.WriteQuaternion(fieldValue, 32);
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = (data.scale.ToCoreVector3());
    

    
                    bitStream.WriteVector3(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static ConnectedEntity Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(4);
                }
    
                var val = new ConnectedEntity();
                if (bitStream.ReadMask())
                {
    
                    val.value = bitStream.ReadEntity();
                    val.FieldsMask |= ConnectedEntity.valueMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.pos = bitStream.ReadVector3(FloatMeta.NoCompression()).ToUnityVector3();
                    val.FieldsMask |= ConnectedEntity.posMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.rot = bitStream.ReadQuaternion(32).ToUnityQuaternion();
                    val.FieldsMask |= ConnectedEntity.rotMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.scale = bitStream.ReadVector3(FloatMeta.NoCompression()).ToUnityVector3();
                    val.FieldsMask |= ConnectedEntity.scaleMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"ConnectedEntity(" +
                    $" value: { this.value }" +
                    $" pos: { this.pos }" +
                    $" rot: { this.rot }" +
                    $" scale: { this.scale }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(4, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(4, '0') })";
            }
        }
        public struct UniqueID : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= UniqueID.uuidMask;
                uuidSimulationFrame = frame;
            }
    
            public static uint uuidMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame uuidSimulationFrame;
            public System.String uuid;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 7;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (UniqueID)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.uuidSimulationFrame = other.uuidSimulationFrame;
                    this.uuid = other.uuid;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(UniqueID data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.uuid;
    

    
                    bitStream.WriteString(fieldValue);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static UniqueID Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new UniqueID();
                if (bitStream.ReadMask())
                {
    
                    val.uuid = bitStream.ReadString();
                    val.FieldsMask |= UniqueID.uuidMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"UniqueID(" +
                    $" uuid: { this.uuid }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct Connection : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= Connection.idMask;
                idSimulationFrame = frame;
                FieldsMask |= Connection.typeMask;
                typeSimulationFrame = frame;
            }
    
            public static uint idMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame idSimulationFrame;
            public System.UInt32 id;
            public static uint typeMask => 0b00000000000000000000000000000010;
            public AbsoluteSimulationFrame typeSimulationFrame;
            public System.Int32 type;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 8;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000011;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 2;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
            private static readonly System.UInt32 _id_Min = 0;
            private static readonly System.UInt32 _id_Max = 2147483647;
            private static readonly System.Int32 _type_Min = 0;
            private static readonly System.Int32 _type_Max = 8;
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (Connection)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.idSimulationFrame = other.idSimulationFrame;
                    this.id = other.id;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.typeSimulationFrame = other.typeSimulationFrame;
                    this.type = other.type;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(Connection data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 2);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.id, _id_Min, _id_Max, "Connection.id", logger);
    
                    data.id = Coherence.Utils.Bounds.Clamp(data.id, _id_Min, _id_Max);
    
                    var fieldValue = data.id;
    

    
                    bitStream.WriteUIntegerRange(fieldValue, 31, 0);
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.type, _type_Min, _type_Max, "Connection.type", logger);
    
                    data.type = Coherence.Utils.Bounds.Clamp(data.type, _type_Min, _type_Max);
    
                    var fieldValue = data.type;
    

    
                    bitStream.WriteIntegerRange(fieldValue, 3, 0);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static Connection Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(2);
                }
    
                var val = new Connection();
                if (bitStream.ReadMask())
                {
    
                    val.id = bitStream.ReadUIntegerRange(31, 0);
                    val.FieldsMask |= Connection.idMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.type = bitStream.ReadIntegerRange(3, 0);
                    val.FieldsMask |= Connection.typeMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"Connection(" +
                    $" id: { this.id }" +
                    $" type: { this.type }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(2, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(2, '0') })";
            }
        }
        public struct ConnectionScene : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= ConnectionScene.valueMask;
                valueSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public System.UInt32 value;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 9;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
            private static readonly System.UInt32 _value_Min = 0;
            private static readonly System.UInt32 _value_Max = 4294967295;
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (ConnectionScene)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(ConnectionScene data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.value, _value_Min, _value_Max, "ConnectionScene.value", logger);
    
                    data.value = Coherence.Utils.Bounds.Clamp(data.value, _value_Min, _value_Max);
    
                    var fieldValue = data.value;
    

    
                    bitStream.WriteUIntegerRange(fieldValue, 32, 0);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static ConnectionScene Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new ConnectionScene();
                if (bitStream.ReadMask())
                {
    
                    val.value = bitStream.ReadUIntegerRange(32, 0);
                    val.FieldsMask |= ConnectionScene.valueMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"ConnectionScene(" +
                    $" value: { this.value }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct Global : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
            }
    
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 10;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000000;
            public bool HasFields() => false;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 0;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (Global)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(Global data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 0);
                }
    
                var mask = data.FieldsMask;
    
    
                return mask;
            }
    
            public static Global Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(0);
                }
    
                var val = new Global();
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"Global(" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(0, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(0, '0') })";
            }
        }
        public struct GlobalQuery : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
            }
    
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 11;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000000;
            public bool HasFields() => false;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 0;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (GlobalQuery)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(GlobalQuery data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 0);
                }
    
                var mask = data.FieldsMask;
    
    
                return mask;
            }
    
            public static GlobalQuery Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(0);
                }
    
                var val = new GlobalQuery();
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"GlobalQuery(" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(0, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(0, '0') })";
            }
        }
        public struct Tag : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= Tag.tagMask;
                tagSimulationFrame = frame;
            }
    
            public static uint tagMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame tagSimulationFrame;
            public System.String tag;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 12;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (Tag)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.tagSimulationFrame = other.tagSimulationFrame;
                    this.tag = other.tag;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(Tag data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.tag;
    

    
                    bitStream.WriteString(fieldValue);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static Tag Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new Tag();
                if (bitStream.ReadMask())
                {
    
                    val.tag = bitStream.ReadString();
                    val.FieldsMask |= Tag.tagMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"Tag(" +
                    $" tag: { this.tag }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct TagQuery : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= TagQuery.tagMask;
                tagSimulationFrame = frame;
            }
    
            public static uint tagMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame tagSimulationFrame;
            public System.String tag;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 13;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (TagQuery)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.tagSimulationFrame = other.tagSimulationFrame;
                    this.tag = other.tag;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(TagQuery data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.tag;
    

    
                    bitStream.WriteString(fieldValue);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static TagQuery Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new TagQuery();
                if (bitStream.ReadMask())
                {
    
                    val.tag = bitStream.ReadString();
                    val.FieldsMask |= TagQuery.tagMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"TagQuery(" +
                    $" tag: { this.tag }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct PreserveChildren : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
            }
    
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 14;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000000;
            public bool HasFields() => false;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 0;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (PreserveChildren)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(PreserveChildren data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 0);
                }
    
                var mask = data.FieldsMask;
    
    
                return mask;
            }
    
            public static PreserveChildren Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(0);
                }
    
                var val = new PreserveChildren();
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"PreserveChildren(" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(0, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(0, '0') })";
            }
        }
        public struct Scene : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= Scene.valueMask;
                valueSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public System.UInt32 value;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 15;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
            private static readonly System.UInt32 _value_Min = 0;
            private static readonly System.UInt32 _value_Max = 2147483647;
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (Scene)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(Scene data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
                    Coherence.Utils.Bounds.Check(data.value, _value_Min, _value_Max, "Scene.value", logger);
    
                    data.value = Coherence.Utils.Bounds.Clamp(data.value, _value_Min, _value_Max);
    
                    var fieldValue = data.value;
    

    
                    bitStream.WriteUIntegerRange(fieldValue, 32, 0);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static Scene Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new Scene();
                if (bitStream.ReadMask())
                {
    
                    val.value = bitStream.ReadUIntegerRange(32, 0);
                    val.FieldsMask |= Scene.valueMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"Scene(" +
                    $" value: { this.value }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }
        public struct AssetId : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= AssetId.valueMask;
                valueSimulationFrame = frame;
                FieldsMask |= AssetId.isFromGroupMask;
                isFromGroupSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public System.Int32 value;
            public static uint isFromGroupMask => 0b00000000000000000000000000000010;
            public AbsoluteSimulationFrame isFromGroupSimulationFrame;
            public System.Boolean isFromGroup;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 16;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000011;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
    
            public long[] GetSimulationFrames() {
                return null;
            }
    
            public int GetFieldCount() => 2;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (AssetId)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                if ((otherMask & 0x01) != 0)
                {
                    this.isFromGroupSimulationFrame = other.isFromGroupSimulationFrame;
                    this.isFromGroup = other.isFromGroup;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(AssetId data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 2);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.value;
    

    
                    bitStream.WriteIntegerRange(fieldValue, 32, -2147483648);
                }
    
                mask >>= 1;
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
    
    
                    var fieldValue = data.isFromGroup;
    

    
                    bitStream.WriteBool(fieldValue);
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static AssetId Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(2);
                }
    
                var val = new AssetId();
                if (bitStream.ReadMask())
                {
    
                    val.value = bitStream.ReadIntegerRange(32, -2147483648);
                    val.FieldsMask |= AssetId.valueMask;
                }
                if (bitStream.ReadMask())
                {
    
                    val.isFromGroup = bitStream.ReadBool();
                    val.FieldsMask |= AssetId.isFromGroupMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"AssetId(" +
                    $" value: { this.value }" +
                    $" isFromGroup: { this.isFromGroup }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(2, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(2, '0') })";
            }
        }
        public struct GenericScale : ICoherenceComponentData
        {
            public void ResetFrame(AbsoluteSimulationFrame frame)
            {
                FieldsMask |= GenericScale.valueMask;
                valueSimulationFrame = frame;
            }
    
            public static uint valueMask => 0b00000000000000000000000000000001;
            public AbsoluteSimulationFrame valueSimulationFrame;
            public Vector3 value;
    
            public uint FieldsMask { get; set; }
            public uint StoppedMask { get; set; }
            public uint GetComponentType() => 17;
            public int PriorityLevel() => 100;
            public const int order = 0;
            public uint InitialFieldsMask() => 0b00000000000000000000000000000001;
            public bool HasFields() => true;
            public bool HasRefFields() => false;
    
            private long[] simulationFrames;
    
            public long[] GetSimulationFrames() {
                if (simulationFrames == null)
                {
                    simulationFrames = new long[1];
                }
    
                simulationFrames[0] = valueSimulationFrame;
    
                return simulationFrames;
            }
    
            public int GetFieldCount() => 1;
    
    
            
            public HashSet<Entity> GetEntityRefs()
            {
                return default;
            }
    
            public uint ReplaceReferences(Entity fromEntity, Entity toEntity)
            {
                return 0;
            }
            
            public IEntityMapper.Error MapToAbsolute(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public IEntityMapper.Error MapToRelative(IEntityMapper mapper)
            {
                return IEntityMapper.Error.None;
            }
    
            public ICoherenceComponentData Clone() => this;
            public int GetComponentOrder() => order;
            public bool IsSendOrdered() => false;
            public bool IsWorldPositionComponent() => false;
    
    
            public AbsoluteSimulationFrame? GetMinSimulationFrame()
            {
                AbsoluteSimulationFrame? min = null;
    
                if ((FieldsMask & GenericScale.valueMask) != 0 && (min == null || this.valueSimulationFrame < min))
                {
                    min = this.valueSimulationFrame;
                }
    
                return min;
            }
    
            public ICoherenceComponentData MergeWith(ICoherenceComponentData data)
            {
                var other = (GenericScale)data;
                var otherMask = other.FieldsMask;
    
                FieldsMask |= otherMask;
                StoppedMask &= ~(otherMask);
    
                if ((otherMask & 0x01) != 0)
                {
                    this.valueSimulationFrame = other.valueSimulationFrame;
                    this.value = other.value;
                }
    
                otherMask >>= 1;
                StoppedMask |= other.StoppedMask;
    
                return this;
            }
    
            public uint DiffWith(ICoherenceComponentData data)
            {
                throw new System.NotSupportedException($"{nameof(DiffWith)} is not supported in Unity");
            }
    
            public static uint Serialize(GenericScale data, bool isRefSimFrameValid, AbsoluteSimulationFrame referenceSimulationFrame, IOutProtocolBitStream bitStream, Logger logger)
            {
                if (bitStream.WriteMask(data.StoppedMask != 0))
                {
                    bitStream.WriteMaskBits(data.StoppedMask, 1);
                }
    
                var mask = data.FieldsMask;
    
                if (bitStream.WriteMask((mask & 0x01) != 0))
                {
                    if (isRefSimFrameValid) {
                        var simFrameDelta = data.valueSimulationFrame - referenceSimulationFrame;
                        if (simFrameDelta > byte.MaxValue) {
                            simFrameDelta = byte.MaxValue;
                        }
    
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, (byte)simFrameDelta);
                    } else {
                        SerializeTools.WriteFieldSimFrameDelta(bitStream, 0);
                    }
    
    
                    var fieldValue = (data.value.ToCoreVector3());
    

    
                    bitStream.WriteVector3(fieldValue, FloatMeta.NoCompression());
                }
    
                mask >>= 1;
    
                return mask;
            }
    
            public static GenericScale Deserialize(AbsoluteSimulationFrame referenceSimulationFrame, InProtocolBitStream bitStream)
            {
                var stoppedMask = (uint)0;
                if (bitStream.ReadMask())
                {
                    stoppedMask = bitStream.ReadMaskBits(1);
                }
    
                var val = new GenericScale();
                if (bitStream.ReadMask())
                {
                    val.valueSimulationFrame = referenceSimulationFrame + DeserializerTools.ReadFieldSimFrameDelta(bitStream);
    
                    val.value = bitStream.ReadVector3(FloatMeta.NoCompression()).ToUnityVector3();
                    val.FieldsMask |= GenericScale.valueMask;
                }
    
                val.StoppedMask = stoppedMask;
    
                return val;
            }
    
    
            public override string ToString()
            {
                return $"GenericScale(" +
                    $" value: { this.value }" +
                    $", valueSimFrame: { this.valueSimulationFrame }" +
                    $" Mask: { System.Convert.ToString(FieldsMask, 2).PadLeft(1, '0') }, " +
                    $"Stopped: { System.Convert.ToString(StoppedMask, 2).PadLeft(1, '0') })";
            }
        }

}
